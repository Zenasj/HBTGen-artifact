# tf.random.uniform((16, 800000), dtype=tf.string) ‚Üê Inferred input shape and type from build_model()

import tensorflow as tf
from tensorflow.keras.layers import Input, StringLookup, Dense
from tensorflow.keras import Model

class MyModel(tf.keras.Model):
    def __init__(self):
        super().__init__()
        # Vocabulary and sequence parameters
        self.vocabulary = list('ABCDEFGHIJKLMN')
        self.seq_length = 800000
        
        # Build layers similar to original model in the issue
        self.string_lookup = StringLookup(
            vocabulary=self.vocabulary,
            mask_token='',
            output_mode='multi_hot',
            name='string_lookup'
        )
        self.dense = Dense(1, activation='sigmoid')
        
    def call(self, inputs):
        # inputs expected shape: (batch_size, 800000), dtype string
        x = self.string_lookup(inputs)
        x = self.dense(x)
        return x

def my_model_function():
    # Return an instance of MyModel
    return MyModel()

def GetInput():
    # Return a random tensor input matching the input expected by MyModel:
    # A (batch_size=16, seq_length=800000) tensor of dtype string with values from vocabulary.
    batch_size = 16
    seq_length = 800000
    vocabulary = list('ABCDEFGHIJKLMN')
    # Use tf.random.uniform to select indices, then map to characters as strings.
    # Since TF string tensors cannot be generated by direct random choice,
    # workaround by generating integer indices and mapping by tf.gather with tf.strings.unicode_encode.
    
    # Create a tensor of shape (batch_size, seq_length) with random indices
    indices = tf.random.uniform(
        shape=(batch_size, seq_length),
        minval=0,
        maxval=len(vocabulary),
        dtype=tf.int32
    )
    # Convert vocabulary list to a tf.constant tensor of strings
    vocab_tensor = tf.constant(vocabulary, dtype=tf.string)
    # Gather strings by indices
    string_tensor = tf.gather(vocab_tensor, indices)
    return string_tensor

